{"meta":{"title":"Rainbow","subtitle":"吃点啥好呢？","description":"","author":"sudatime","url":"https://blog.sodarain.top","root":"/"},"pages":[{"title":"404","date":"2020-08-10T07:00:30.515Z","updated":"2020-08-10T07:00:30.515Z","comments":false,"path":"/404.html","permalink":"https://blog.sodarain.top/404.html","excerpt":"","text":"404 Not Found 对不起，您所访问的页面不存在或者已删除 点击此处返回首页 我的Github：https://github.com/sudatime/"},{"title":"关于","date":"2020-08-09T12:29:00.000Z","updated":"2020-08-10T03:50:24.462Z","comments":true,"path":"about/index.html","permalink":"https://blog.sodarain.top/about/index.html","excerpt":"","text":"兴趣使然~"},{"title":"分类","date":"2020-08-10T00:43:13.000Z","updated":"2020-08-13T08:36:36.456Z","comments":false,"path":"categories/index.html","permalink":"https://blog.sodarain.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-10T00:43:09.000Z","updated":"2020-08-13T08:36:46.050Z","comments":false,"path":"tags/index.html","permalink":"https://blog.sodarain.top/tags/index.html","excerpt":"","text":""},{"title":"yourdiy","date":"2020-08-09T12:29:08.000Z","updated":"2020-08-13T08:36:55.482Z","comments":false,"path":"yourdiy/index.html","permalink":"https://blog.sodarain.top/yourdiy/index.html","excerpt":"","text":""}],"posts":[{"title":"单点登录实现","slug":"单点登录实现","date":"2020-08-19T06:08:21.000Z","updated":"2020-08-19T06:34:16.627Z","comments":true,"path":"/essay/9fd432c.html/","link":"","permalink":"https://blog.sodarain.top/essay/9fd432c.html/","excerpt":"单点登录（Single Sign On），简称为SSO，是比较流行的企业业务整合的解决方案之一。","text":"单点登录（Single Sign On），简称为SSO，是比较流行的企业业务整合的解决方案之一。 实现方案Oauth2：可以生成一个令牌的，经过用户验证（客户端、真实用户）生成令牌。 cookie用户访问被保护的资源时要经过网关，网关会从里面得到cookie，再从cookie中取出JTI值，可用JTI值作为键值，从redis里面获取token值，验证token。 完整流程： 用户访问资源的时候，网关取得请求的URL，来判断是否放行。 若用户访问的资源是被保护的，则网关不放行，并从中获取cookie值，如果里面不存在cookie，则跳转去登录页面。 当用户登录的时候，会进入登录服务里面，由于登录服务并没有校验密码的功能，我们需要借助于Oauth2服务。 Oauth2拿到用户名密码之后，会查询数据库来判断用户名密码是否正确，当密码正确时，会发放一个令牌给登录用户。 当登录服务拿到令牌之后，会把token以JTI值为键存入redis，并将JTI值存入cookie中。 再次回到网关，网关会重复第2步，若仍然不存在，则继续进入登录服务。若cookie存在，并成功取到token，当校验通过，则可以访问被保护的资源了 实现代码： 获取请求的URL 12ServerHttpRequest request = exchange.getRequest();String path = request.getURI().getPath(); 转发： 1234567//跳转登录页面 - 303private Mono&lt;Void&gt; toLoginPage(String loginUrl, ServerWebExchange exchange) &#123; ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(HttpStatus.SEE_OTHER); response.getHeaders().set(&quot;Location&quot;,loginUrl); return response.setComplete();&#125; 取cookie 1HttpCookie httpCookie = request.getCookies().getFirst(&quot;uid&quot;); 给request请求添加header 1request.mutate().header(&quot;Authorization&quot;,&quot;Bearer &quot;+jwt);","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.sodarain.top/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"sso","slug":"sso","permalink":"https://blog.sodarain.top/tags/sso/"}]},{"title":"vue与button的冲突","slug":"vue与button的冲突","date":"2020-08-19T02:41:40.000Z","updated":"2020-08-19T02:54:05.245Z","comments":true,"path":"/essay/vue-button.html/","link":"","permalink":"https://blog.sodarain.top/essay/vue-button.html/","excerpt":"环境：1vue.js v2.5.16 问题描述：1&lt;button&gt;&lt;/button&gt; 这个标签未设置type属性时，在form表单中会默认为submit属性，也就是表单提交事件。 当vue指定@click事件在这个button上时，就会出现两次请求的触发。 出现同步请求的现象（也就是页面刷新一次）","text":"环境：1vue.js v2.5.16 问题描述：1&lt;button&gt;&lt;/button&gt; 这个标签未设置type属性时，在form表单中会默认为submit属性，也就是表单提交事件。 当vue指定@click事件在这个button上时，就会出现两次请求的触发。 出现同步请求的现象（也就是页面刷新一次） 解决方法方案一：使用高版本vue.js 实测vue.js : 2.6.11可解决问题，但是仍然有同步请求现象 方案二：给form内的button加上type属性，这个最为方便快捷 1&lt;button type=&quot;button&quot; @click=&quot;pageNum=1;findPage()&quot; class=&quot;btn btn-default&quot;&gt;查询&lt;/button&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://blog.sodarain.top/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.sodarain.top/tags/vue/"}]},{"title":"next主题下中文标题跳转失效","slug":"next主题中文标题无法跳转","date":"2020-08-15T07:18:59.000Z","updated":"2020-08-15T07:52:52.708Z","comments":true,"path":"/essay/80ff7aac.html/","link":"","permalink":"https://blog.sodarain.top/essay/80ff7aac.html/","excerpt":"next 7.8版本发布于2020年4月1日，很久没更新 该bug导致中文标题无法跳转，但是英文标题可以","text":"next 7.8版本发布于2020年4月1日，很久没更新 该bug导致中文标题无法跳转，但是英文标题可以 环境：hexo 5.0 next 7.8 原因: 由上图可知，utils中的一行代码出了问题，导致后面的一系列出了问题 于是我先是去搜索了一下这个问题，但是并没有人写过相关内容 最终 在官方代码最新的commit中，我看到了这样的一个提交。 但是即使将此次提交变动的代码修改之后也不可以，会出现另一个错误。 解决方案:将下面这个链接的整个代码全部复制，粘贴到\\themes\\next\\source\\js\\utils.js中，问题完美解决 访问官方的github仓库获取最新的utils.js代码","categories":[{"name":"next","slug":"next","permalink":"https://blog.sodarain.top/categories/next/"},{"name":"bug","slug":"next/bug","permalink":"https://blog.sodarain.top/categories/next/bug/"}],"tags":[{"name":"next","slug":"next","permalink":"https://blog.sodarain.top/tags/next/"}]},{"title":"爬取武生院教务处通知","slug":"爬取教务处通知","date":"2020-08-15T07:15:20.576Z","updated":"2020-08-15T02:09:06.944Z","comments":true,"path":"/essay/wsy-crawler.html/","link":"","permalink":"https://blog.sodarain.top/essay/wsy-crawler.html/","excerpt":"记录一下之前因为某些特殊原因而要去爬取武生院网站通知的代码，防止后面有别的需要而忘记使用方法。","text":"记录一下之前因为某些特殊原因而要去爬取武生院网站通知的代码，防止后面有别的需要而忘记使用方法。 Jsoup介绍jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 –来源百度百科 环境采用Springboot 2.3.0搭建环境 依赖如下： 1234567891011&lt;!--起步依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--此为核心包 jsoup爬虫--&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt;&lt;/dependency&gt; 核心代码12345678910111213141516171819202122public boolean getNotice(Integer tbodyIndex, Integer trNum) throws Exception &#123; //获取document对象 Document document = Jsoup.connect(URL).get(); //获取第7个tbody的内容 Elements tbody = document.select(&quot;tbody&quot;).eq(tbodyIndex); //System.out.println(tbody.toString()); List&lt;Article&gt; articles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; trNum; i++) &#123; Elements tr = tbody.select(&quot;tr&quot;).eq(i); Elements td1 = tr.select(&quot;td&quot;).eq(0); Elements td2 = tr.select(&quot;td&quot;).eq(2); String href = URL + td1.select(&quot;a&quot;).attr(&quot;href&quot;); int index = href.indexOf(&quot;id&quot;); //截取id的数字字段 String id = href.substring(index + 3, index + 7); String body = td1.select(&quot;a&quot;).text(); String date = td2.text(); Article article = new Article(Integer.parseInt(id), body, href, DateUtils.parseString2Date(date)); articles.add(article); &#125; return sendMessage(articles);&#125; 思路1Document document = Jsoup.connect(URL).get(); 这行代码能够访问指定的URL路径来获取返回的静态页面 通过分析得到的html可以得知我们想要的新闻通知区域在第7个tbody中 打印输出的tbody，可以发现数据都存放在tr标签里面，分了三个td小标签 我们只取我们想要的数据： 第一个td里面是文章链接，不带域名的。 第二个td里面是文章后面的gif图片，没啥用 第三个td里面是日期 所以我们可以使用 12Elements td1 = tr.select(&quot;td&quot;).eq(0);Elements td2 = tr.select(&quot;td&quot;).eq(2); 来获取链接和日期 使用Article对象来进行封装。得到文章对象之后，要做什么处理就方便了。 意外收获写完之后想继续爬取其他模块的，意外的发现其他模块结构类似，只是tbody和tr值不同，所以封装成一个方法。 1234567891011121314151617181920//新闻通知boolean news = getNotice(6, 9);//教务管理boolean manage = getNotice(11, 6);//教学研究boolean research = getNotice(13, 6);//学籍管理boolean schoolRoll = getNotice(15, 6);//实践教学boolean practice = getNotice(21, 6);//质量管理boolean quality = getNotice(23, 6);//下载专区boolean download = getNotice(25, 6);//工作例会boolean work = getNotice(29, 6);//考务管理boolean exam = getNotice(31, 6);//学习动态boolean study = getNotice(33, 6);","categories":[{"name":"crawler","slug":"crawler","permalink":"https://blog.sodarain.top/categories/crawler/"},{"name":"wsy","slug":"crawler/wsy","permalink":"https://blog.sodarain.top/categories/crawler/wsy/"}],"tags":[{"name":"crawler","slug":"crawler","permalink":"https://blog.sodarain.top/tags/crawler/"}]},{"title":"valine改为本地加载","slug":"valine改为本地加载","date":"2020-08-13T01:52:27.000Z","updated":"2020-08-15T01:07:53.097Z","comments":true,"path":"/essay/802f7ce0.html/","link":"","permalink":"https://blog.sodarain.top/essay/802f7ce0.html/","excerpt":"环境主题next7.8 valine 1.4.14 找到模板源文件通过以下路径找到 1\\themes\\next\\layout\\_third-party\\comments\\valine.swig","text":"环境主题next7.8 valine 1.4.14 找到模板源文件通过以下路径找到 1\\themes\\next\\layout\\_third-party\\comments\\valine.swig 打开代码 1&#123;%- set valine_uri &#x3D; theme.vendors.valine or &#39;&#x2F;&#x2F;unpkg.com&#x2F;valine&#x2F;dist&#x2F;Valine.min.js&#39; %&#125; 从第一行代码可以看出，它是通过网络加载，然后用NexT.utils来进行获取参数 我们可以不用管，直接删掉 123456NexT.utils.getScript(&#39;&#123;&#123; valine_uri &#125;&#125;&#39;, () &#x3D;&gt; &#123; var GUEST &#x3D; [&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]; var guest &#x3D; &#39;&#123;&#123; theme.valine.guest_info &#125;&#125;&#39;; guest &#x3D; guest.split(&#39;,&#39;).filter(item &#x3D;&gt; &#123; return GUEST.includes(item); &#125;); 只留下主体new Valine 代码 这样操作会导致读取不到guest 应该这样写 ↓ 123456789101112131415161718192021222324&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;Valine.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var GUEST &#x3D; [&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]; var guest &#x3D; &#39;&#123;&#123; theme.valine.guest_info &#125;&#125;&#39;; guest &#x3D; guest.split(&#39;,&#39;).filter(item &#x3D;&gt; &#123; return GUEST.includes(item); &#125;); new Valine(&#123; el : &#39;#valine-comments&#39;, verify : &#123;&#123; theme.valine.verify &#125;&#125;, notify : &#123;&#123; theme.valine.notify &#125;&#125;, appId : &#39;&#123;&#123; theme.valine.appid &#125;&#125;&#39;, appKey : &#39;&#123;&#123; theme.valine.appkey &#125;&#125;&#39;, placeholder: &#123;&#123; theme.valine.placeholder | json &#125;&#125;, avatar : &#39;&#123;&#123; theme.valine.avatar &#125;&#125;&#39;, meta : guest, pageSize : &#39;&#123;&#123; theme.valine.pageSize &#125;&#125;&#39; || 10, visitor : &#123;&#123; theme.valine.visitor &#125;&#125;, lang : &#39;&#123;&#123; theme.valine.language &#125;&#125;&#39; || &#39;zh-cn&#39;, path : location.pathname, recordIP : &#123;&#123; theme.valine.recordIP &#125;&#125;, serverURLs : &#39;&#123;&#123; theme.valine.serverURLs &#125;&#125;&#39; &#125;);&lt;&#x2F;script&gt; Valine.min.js获取方式访问 这里 复制全部代码，新建一个Valine.min.js，放进去 保存 放在 主题\\source\\js里面","categories":[{"name":"next","slug":"next","permalink":"https://blog.sodarain.top/categories/next/"},{"name":"valine","slug":"next/valine","permalink":"https://blog.sodarain.top/categories/next/valine/"}],"tags":[{"name":"valine","slug":"valine","permalink":"https://blog.sodarain.top/tags/valine/"}]},{"title":"nginx实现负载均衡","slug":"nginx实现负载均衡","date":"2020-08-11T08:38:12.000Z","updated":"2020-08-15T02:07:48.543Z","comments":true,"path":"/essay/nginx-config.html/","link":"","permalink":"https://blog.sodarain.top/essay/nginx-config.html/","excerpt":"Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。记录一下nginx负载均衡的实现，配置文件如下：","text":"Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。记录一下nginx负载均衡的实现，配置文件如下： 在http节点下，添加upstream节点。 1234upstream abc &#123; server localhost:7080; server localhost:8980; &#125; 将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称，即 123456location &#x2F; &#123; root html; &#x2F;&#x2F;http:&#x2F;&#x2F; + upstream名称 proxy_pass http:&#x2F;&#x2F;abc; index index.html index.htm; &#125; upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。适用于图片服务器集群和纯静态页面服务器集群。除此之外，upstream还有其它的分配策略，分别如下： weight（权重） 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。如下所示，10.0.0.88的访问比率要比10.0.0.77的访问比率高一倍。 1234upstream linuxidc&#123; server 10.0.0.77 weight&#x3D;5; server 10.0.0.88 weight&#x3D;10; &#125; ip_hash（访问ip） 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream favresin&#123; ip_hash; server 10.0.0.10:8080; server 10.0.0.11:8080; &#125; fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。 12345 upstream abc&#123; server 10.0.0.10:8080; server 10.0.0.11:8080; fair; &#125; url_hash（第三方） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 注意：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。 123456 upstream abc&#123; server 10.0.0.10:7777; server 10.0.0.11:8888; hash $request_uri; hash_method crc32; &#125; upstream还可以为每个设备设置状态值，这些状态值的含义分别如下： down 表示单前的server暂时不参与负载. weight 默认为1.weight越大，负载的权重就越大。 max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误. fail_timeout : max_fails次失败后，暂停的时间。 backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 1234567upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 ip_hash; server 10.0.0.11:9090 down; server 10.0.0.11:8080 weight&#x3D;2; server 10.0.0.11:6060; server 10.0.0.11:7070 backup; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.sodarain.top/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nginx","slug":"后端/nginx","permalink":"https://blog.sodarain.top/categories/%E5%90%8E%E7%AB%AF/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.sodarain.top/tags/nginx/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://blog.sodarain.top/categories/%E5%90%8E%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://blog.sodarain.top/categories/vue/"},{"name":"next","slug":"next","permalink":"https://blog.sodarain.top/categories/next/"},{"name":"bug","slug":"next/bug","permalink":"https://blog.sodarain.top/categories/next/bug/"},{"name":"crawler","slug":"crawler","permalink":"https://blog.sodarain.top/categories/crawler/"},{"name":"wsy","slug":"crawler/wsy","permalink":"https://blog.sodarain.top/categories/crawler/wsy/"},{"name":"valine","slug":"next/valine","permalink":"https://blog.sodarain.top/categories/next/valine/"},{"name":"nginx","slug":"后端/nginx","permalink":"https://blog.sodarain.top/categories/%E5%90%8E%E7%AB%AF/nginx/"}],"tags":[{"name":"sso","slug":"sso","permalink":"https://blog.sodarain.top/tags/sso/"},{"name":"vue","slug":"vue","permalink":"https://blog.sodarain.top/tags/vue/"},{"name":"next","slug":"next","permalink":"https://blog.sodarain.top/tags/next/"},{"name":"crawler","slug":"crawler","permalink":"https://blog.sodarain.top/tags/crawler/"},{"name":"valine","slug":"valine","permalink":"https://blog.sodarain.top/tags/valine/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.sodarain.top/tags/nginx/"}]}